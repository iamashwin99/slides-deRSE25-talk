<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/fzj-white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">

			<div class="slides">
				<section data-menu-title="Cover Slide">
					<h1>Credibility and Reproducibility of Scientific Simulations on the Blockchain</h1>
					<h2>deRSE25 Conference</h2>
					Feb 26 2025 | Ashwin Kumar Karnad

					<aside class="notes">
						So this is a very broad idea and in an very primitive stage, there is plenty that I dont know about and 15 minutes is also not enough to cover all of my thoughts. So my idea for the talk is to introduce roughly the concepts that I find interesting  and create a base line for further discussion and collaborations, so this talk is basically a conversation starter.
					</aside>
				</section>
				<section data-menu-title="Problems with reproducibility">

					<section data-menu-title="Problem">
						<h2>The problem of reproducibility in science</h2>
						<h4>Have you failed to reproduce an experiment?</h4>
						<img src="img/reproducibility-graphic.jpg" width="60%" >
						<br>
						<a href="https://doi.org/10.1038/533452a">[Baker, M. 1,500 scientists lift the lid on reproducibility. Nature 533, 452-454 (2016)]</a>
					</section>
					<section data-menu-title="Problem">
						<h2>The problems continued...</h2>
						<ul>
							<li>Analysed and published data not in sync</li>
							<li>Missing link between the analyser and the publisher</li>
						</ul>
					</section>

					<section data-menu-title="State of the Art">
						<h2>Current State of the Art </h2>
						<ul>
							<li>Version-controlled code to track changes.</li>
							<li>Dependency tracking to ensure consistency.</li>
							<li>Specified hardware configurations.</li>
							<li>Use of Docker for one-click simulation setups.</li>

						</ul>
							<aside class="notes">
								<ul>
									<li>Impact of host kernel changes on Dockerized simulations.</li>
									<li>Non-deterministic simulations (e.g., Monte Carlo methods) may yield varied results even on identical setups.</li>
								</ul>
							</aside>
					</section>

					<section data-menu-title="Problem Reasons">
						<h2>Why is there nondeterminism?</h2>
						<ul>
							<li>Floating-Point Arithmetic and hardware differences</li>
							<li>Concurrency Parallelism and Race conditions</li>
							<li>External Input and Environmental Factors</li>
							<li>Hardware and Low-Level Execution</li>
							<li>...</li>
						</ul>
						<aside class="notes">
							<ul>
								<li>
									Floating-Point Arithmetic and Numerical Instability
									<ul>
										<li>Non-Associativity/Non-Commutativity:</li>
										<li>Compiler/Hardware Differences: Variations in instruction sets (SSE vs. AVX), or math libraries (e.g., libm vs. Intel MKL).</li>
									</ul>
								</li>
								<li>
									Concurrency and Parallelism
									<ul>
										<li>Thread Scheduling: OS-dependent thread/process scheduling causing race conditions or inconsistent memory states in multithreaded code.</li>
										<li>Non-Atomic Operations: Torn reads/writes on shared variables without proper synchronization.</li>
										<li>JIT Compilation: Runtime optimizations in Java/.NET/JavaScript causing timing differences.</li>
									</ul>
								</li>
								<li>
									External Input and Environmental Factors
									<ul>
										<li>Randomness: Unseeded or time-seeded random number generators (RNGs).</li>
										<li>I/O interactions: Input from sensors, networks, files, or user interactions varying between runs.</li>
										<li>Clock Dependency: Logic relying on system time or timers (e.g., sleep() durations).</li>
									</ul>
								</li>

								<li>
									Hardware and Low-Level Execution
									<ul>
										<li>Speculative Execution: Side effects from mispredicted branches (e.g., cache timing leaks) in CPUs.</li>
										<li>Memory Address Randomization (ASLR): Pointer values differing across runs, affecting hashing or debugging.</li>
										<li>Thermal Throttling: CPU performance fluctuations altering thread timing.</li>
									</ul>
								</li>
							</ul>

							The same requirements for deterministic compute also happens in another universe called the blockchain and they seem to have solution for this, so this talk is about identifying ideas from them.
						</aside>

					</section>



				</section>

				<section data-menu-title="Blockchain Intro">

					<section data-menu-title="Blockchain is a decentralised computer">
						<h2>Blockchain as a decentralised global computer</h2>
						<ul>
							<li>Transactions (computations) are state transitions</li>
							<li>State is stored in a distributed ledger</li>
							<li>Consensus is achieved through validators</li>
						</ul>
					</section>

					<section data-menu-title="Need for determinism in BC">
						<h2>Need for determinism in blockchain</h2>
						<ul>
							<li>Consensus requires all nodes to agree on the state</li>
							<li>Non-deterministic computations can lead to forks</li>
							</ul>
					</section>
					<section data-menu-title="How determinism is achieved">
						<h2>How determinism is achieved</h2>
						<ul>
							<li>No floating point instructions</li>
							<li>Single threaded</li>
							<li>Controlling External Inputs</li>
							<li>Controlling Random numbers</li>
							<li>Bytecode Standardization</li>
						</ul>
						<aside class="notes">
							<li>No Floating-Point Arithmetic
								<ul>
									<li>EVM uses 256-bit integers and fixed-point arithmetic.</li>
								</ul>
							</li>
							<li>Eliminating Concurrency and Parallelism
								<ul>
									<li>EVM processes transactions sequentially within a block.</li>
									<li>All nodes process transactions in the same order.</li>
								</ul>
							</li>
							<li>Controlling External Inputs
								<ul>
									<li>Smart contracts cannot access off-chain data unless via oracles.</li>
									<li>Contracts can only access data from the current or previous blocks.</li>
								</ul>
							</li>
							<li>Managing Randomness
								<ul>
									<li>On-chain "randomness" is deterministic and known to all nodes.</li>
									<li>Contracts use Commit-Reveal Schemes or Oracle-Based RNG.</li>
								</ul>
							</li>
							<li>Enforcing Deterministic Execution Environments
								<ul>
									<li>EVM is a sandboxed virtual machine, abstracting hardware differences.</li>
									<li>Every opcode has a fixed gas cost.</li>
									<li>No speculative execution.</li>
								</ul>
							</li>
							<li>Consensus-Driven State Transition
								<ul>
									<li>All nodes start from the same genesis state and apply transactions in the same order.</li>
									<li>Transactions are replayed identically on every node.</li>
								</ul>
							</li>
							<li>Bytecode Standardization
								<ul>
									<li>High-level code is compiled to standardized EVM bytecode.</li>
									<li>No JIT or runtime compilation.</li>
								</ul>
							</li>
						</ul>
						Perhaps then could we leverage the blockchain for scientific simulations? At least for simple calculations?

					</section>
				</section>

				<section data-menu-title="Onchain simulations">

					<section data-menu-title="Onchain simulations">
						<h2>Running simulations "on chain"</h2>
						<ul>
							<li>Completely Reproducible </li>
							<li>Provenance and authorship is proveable</li>
						</ul>
						<aside class="notes">
							<ul>
								<li>detect manipulation.</li>
								<li>Provenance can be established</li>
							</ul>
						</aside>
					</section>

					<section data-menu-title="Example">
						<h2>Example simulations</h2>
						<iframe frameborder="0" scrolling="yes" style="width:100%; height:500px;" allow="clipboard-write" src="https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2Fiamashwin99%2FdeRSE25-simulation-on-ethereum-examples%2Fblob%2Fmain%2FREADME.md&style=default&type=markdown&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on"></iframe>
						<p>
							<a href="https://github.com/iamashwin99/deRSE25-simulation-on-ethereum-examples">Source code on Github</a>
						</p>
					</section>

					<section data-menu-title="Downsides">
						<h2>Limitations of on chain simulations</h2>
						<ul>
							<li>Lack of math function (exponents, matrices, floating point, randomness)</li>
							<li>Costs (Computation and storage)</li>
							<li>Speed</li>
						</ul>
						<aside class="notes">
							<ul>
								<li>randomness per block, oracles </li>
								<li>cost per 10k addition: $0.09 </li>
								<li>cost per kb:10 euros </li>
								<li>development of EVMs that are compute native?</li>
								<li>distributed computing as currency / service ie global computer</li>
							</ul>
							One need for reproducibility is to verify that the authors input and process leads to the claimed output. Typically you do this by running the same code that the authors used and same input. Can we do something else too? In the block chain world often expensive and long calculation is done off chain and only the proof of execution of this is sent to the block chain
					</section>



				</section>

				<section data-menu-title="Off chain simulations">

					<section data-menu-title="Off chain simulations">
						<h2>Running simulations "off chain"</h2>
						<ul>
							<li>Use blockchain for provenance and authorship</li>
							<li>Use merkle trees for hashing the call stack</li>
						</ul>
						<aside class="notes">

						</aside>
					</section>

					<section data-menu-title="merkle trees">
						<h2>Using merkle trees for hashing call stack</h2>
						<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hash_Tree.svg/2560px-Hash_Tree.svg.png" alt="Merkle Tree" style="max-width: 75%; height: auto;">
						<br>
						<small>Merkle trees calculation.</small>
						<br>
						<a href="https://en.wikipedia.org/wiki/Merkle_tree">[Source: Wikipedia]</a>
						<aside class="notes">

						</aside>
					</section>
					<section data-menu-title="Example">
						<h2>Example simulations</h2>
						<iframe frameborder="0" scrolling="yes" style="width:100%; height:500px;" allow="clipboard-write" src="https://emgithub.com/iframe.html?target=https%3A%2F%2Fgithub.com%2Fiamashwin99%2FdeRSE25-simulation-on-ethereum-examples%2Fblob%2Fmain%2Fsrc%2F1d-RandomWalk%2FREADME.md&style=default&type=markdown&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on"></iframe>
						<p>
							<a href="https://github.com/iamashwin99/deRSE25-simulation-on-ethereum-examples/tree/main/src/1d-RandomWalk">Source code on Github</a>
						</p>
					</section>


				</section>


			</div>




		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/search/search.js"></script>
		<!-- <script src="plugin/zoom/zoom.js"></script> -->
		<script src="plugin/reveal.js-menu/menu.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [
				RevealMarkdown,
				RevealHighlight,
				RevealNotes,
				RevealMath.KaTeX,
				RevealSearch,
				// RevealZoom,
				RevealMenu ]

			});
		</script>
	</body>
</html>
